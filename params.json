{
  "name": "Vuex-actions",
  "tagline": "Action utilities for Vuex, supports promise-based async actions.",
  "body": "# vuex-actions\r\n\r\n> Action utilities for Vuex, supports promise-based async actions, inspired by [redux-actions][1].\r\n\r\n[![Travis](https://img.shields.io/travis/weinot/vuex-actions.svg?style=flat)](https://travis-ci.org/weinot/vuex-actions)\r\n[![Codecov](https://img.shields.io/codecov/c/github/weinot/vuex-actions.svg?maxAge=2592000)](https://codecov.io/gh/weinot/vuex-actions)\r\n[![npm](https://img.shields.io/npm/v/vuex-actions.svg?style=flat)](https://www.npmjs.com/package/vuex-actions)\r\n[![npm](https://img.shields.io/npm/dt/vuex-actions.svg?style=flat)](https://www.npmjs.com/package/vuex-actions)\r\n[![JavaScript Style Guide](https://img.shields.io/badge/code%20style-standard-brightgreen.svg)](http://standardjs.com/)\r\n[![npm](https://img.shields.io/npm/l/vuex-actions.svg?maxAge=2592000)]()\r\n\r\nWell tested with vuex@1.0.0-rc.2 and vuex@2.0.0-rc.3, for other versions, use at your own risk :red_circle:.\r\n\r\n```js\r\nnpm install --save vuex-actions\r\n```\r\n```js\r\nimport { createAction, handleAction, handleMutations, $inject } from 'vuex-actions'\r\n```\r\n\r\n### `createAction(type, payloadCreator = Identity)`\r\n\r\nWraps a `Vuex` action so that it has the ability to handle both normal actions and promise-based async actions, commit mutations with the resolved payload created by `payloadCreator`. If no payload creator is passed, or if it's not a function, the identity function is used. **The parameter `type` is considered as a mutation's name**, it will be automatically triggered in the action.\r\n\r\nExample:\r\n\r\n```js\r\nlet increment = createAction('INCREMENT', amount => amount)\r\n// same as\r\nincrement = createAction('INCREMENT')\r\n\r\nexpect(increment).to.be.a('function')\r\n```\r\n\r\n### `handleAction(handlers)`\r\n\r\nWraps a mutation handler so that it can handle async actions created by `createAction`.\r\n\r\nIf a single handler is passed, it is used to handle both normal actions and success actions. (A success action is analogous to a resolved promise)\r\n\r\nOtherwise, you can specify separate handlers for pending(), success() and error(). It's useful for tracking async action's status.\r\n\r\nExample:\r\n\r\n```js\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    obj: null\r\n  },\r\n  mutations: {\r\n\tSINGLE: handleAction((state, mutation) => {\r\n\t  state.obj = mutation\r\n\t}),\r\n    CHANGE: handleAction({\r\n      pending (state, mutation) {\r\n\t    state.obj = mutation\r\n\t  },\r\n\t  success (state, mutation) {\r\n\t    state.obj = mutation\r\n\t  },\r\n\t  error (state, mutation) {\r\n\t    state.obj = mutation\r\n\t  }\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n### `handleMutations(mutations)`\r\nWraps a set of mutations with handleAction. The example above is the same as below\r\n```js\r\nmutations: handleMutations({\r\n  SINGLE: (state, mutation) => {\r\n    state.obj = mutation\r\n  },\r\n  CHANGE: {\r\n    pending(state, mutation) {\r\n      state.obj = mutation\r\n    },\r\n    success(state, mutation) {\r\n      state.obj = mutation\r\n    },\r\n    error(state, mutation) {\r\n      state.obj = mutation\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n**Normal actions**\r\n\r\n```js\r\nconst vm = new Vue({\r\n  store,\r\n  vuex: {\r\n    actions: {\r\n      single: createAction('SINGLE')\r\n    }\r\n  }\r\n})\r\n\r\nvm.single(1)\r\nexpect(store.state.obj).to.equal(1)\r\n\r\nvm.single(null)\r\nexpect(store.state.obj).to.be.null\r\n\r\nvm.single({a: 1})\r\nexpect(store.state.obj).to.be.an('object')\r\n\r\n// for vuex 2.x, the usage is similar\r\nstore.dispatch('single', 1)\r\nexpect(store.state.obj).to.equal(1)\r\n```\r\n\r\n**Async actions**\r\n\r\n```js\r\nconst vm = new Vue({\r\n  store,\r\n  vuex: {\r\n    actions: {\r\n      change: createAction('CHANGE')\r\n    }\r\n  }\r\n})\r\n```\r\n\r\nGive a promise as payload\r\n\r\n```js\r\nvm.change(Promise.resolve(1)).then(() => {\r\n  expect(store.state.obj).to.equal(1)\r\n})\r\n\r\nvm.change(Promise.reject(new Error('wow, it\\'s rejected'))).then(() => {\r\n  expect(store.state.obj).to.be.an.instanceof(Error)\r\n  expect(store.state.obj.message).to.equal('wow, it\\'s rejected')\r\n})\r\n```\r\n\r\nHandle parallel promises in payload\r\n\r\n```js\r\nconst p1 = new Promise((resolve) => setTimeout(() => resolve(1), 300))\r\nconst p2 = new Promise((resolve) => setTimeout(() => resolve(2), 300))\r\n\r\nvm.change({\r\n  p1,\r\n  p2,\r\n  other: 3\r\n}).then(() => {\r\n  expect(store.state.obj).to.eql({\r\n    p1: 1,\r\n    p2: 2,\r\n    other: 3\r\n  })\r\n})\r\n```\r\n\r\nHandle rejected promise in payload\r\n```js\r\nconst p1 = new Promise((resolve) => setTimeout(() => resolve(1), 100))\r\nconst p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => reject(new Error('Something went wrong')), 100)\r\n})\r\n\r\nvm.change({\r\n  p1,\r\n  p2,\r\n  other: 3\r\n}).then(() => {\r\n  expect(store.state.obj).to.be.an('error')\r\n  expect(store.state.obj.message).to.equal('Something went wrong')\r\n})\r\n```\r\n\r\nUsing `$inject` to handle promises (has denpendencies) in sequence\r\n```js\r\nconst p1 = Promise.resolve(1)\r\nconst p2 = Promise.resolve(2)\r\nconst getP3 = p2 => Promise.resolve(p2 + 1)\r\nconst getP4 = p3 => Promise.resolve(p3 + 1)\r\nconst getP5 = (p3, p4) => Promise.resolve(p3 + p4)\r\nconst getP6 = (p4, p5) => Promise.resolve(p4 + p5)\r\n\r\nstore.dispatch(CHANGE, {\r\n  p1,\r\n  p2,\r\n  p3: $inject(getP3)('p2'),\r\n  p4: $inject(getP4)('p3'),\r\n  p5: $inject(getP5)('p3', 'p4'),\r\n  p6: $inject(getP6)('p4', 'p5'),\r\n  other: 'other'\r\n}).then(() => {\r\n  expect(store.state.obj).to.eql({\r\n    p1: 1,\r\n    p2: 2,\r\n    p3: 3,\r\n    p4: 4,\r\n    p5: 7,\r\n    p6: 11,\r\n    other: 'other'\r\n  })\r\n})\r\n```\r\n\r\nAccess origin args in the dependent function\r\n```js\r\nconst testArgs = createAction('CHANGE', options => ({\r\n  p1: new Promise((resolve) => setTimeout(() => resolve(1), 10)),\r\n  p2: new Promise((resolve) => setTimeout(() => resolve(2), 20)),\r\n  p3: $inject((p1, p2, options) => {\r\n    expect(p1).to.equal(1)\r\n    expect(p2).to.equal(2)\r\n    expect(options).to.be.an('object')\r\n    expect(options.opt1).to.equal('opt1')\r\n    expect(options.opt2).to.equal('opt2')\r\n    return Promise.resolve(p1 + p2)\r\n  })('p1', 'p2')\r\n}))\r\n\r\ntestArgs(vm.$store, {\r\n  opt1: 'opt1',\r\n  opt2: 'opt2'\r\n})\r\n```\r\n\r\n### Usage with plugin\r\n\r\n```js\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    obj: null,\r\n    status: ''\r\n  },\r\n  plugins: [\r\n    store => {\r\n      store.subscribe((mutation, state) => {\r\n\t\t// vuex 1.x\r\n        state.status = mutation.payload[0].__status__\r\n\t\t// vuex 2.x\r\n\t\tstate.status = mutation.payload.__status__\r\n\t\t\r\n\t\t// status can be one of ['pending', 'success', 'error']\r\n      })\r\n    }\r\n  ]\r\n})\r\n```\r\n\r\n[1]: https://github.com/acdlite/redux-actions\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}